// Title: Elektro
// Author: FAL
// Date: 9. Nov. 2017
// Made with p5.js v0.5.16
// Generated by TypeScript v2.5.3
"use strict";

//
// ------------ Background ---------------------------------------
//
class AlphaBackground {
    constructor(backgroundColor, drawIntervalFrameCount = 1, blendModeString) {
        this.backgroundColor = backgroundColor;
        this.drawIntervalFrameCount = drawIntervalFrameCount;
        this.blendModeString = blendModeString;
    }
    draw() {
        if (frameCount % this.drawIntervalFrameCount !== 0)
            return;
        if (this.blendModeString)
            blendMode(this.blendModeString);
        noStroke();
        fill(this.backgroundColor);
        rect(0, 0, width, height);
        if (this.blendModeString)
            blendMode(BLEND);
    }
}
//
// ------------ Kinematic quantity -----------------------------
//
class KinematicQuantity {
    constructor() {
        this.position = createVector();
        this.velocity = createVector();
    }
    step() {
        this.position.add(this.velocity);
    }
    accelerate(x, y) {
        this.velocity.add(x, y);
    }
}
//
// ------------ Rotational quantity ---------------------------------------
//
class RotationalQuantity {
    constructor() {
        this.angle = 0;
        this.angleVelocity = 0;
    }
    step() {
        this.angle += this.angleVelocity;
    }
}
//
// --------- ShapeColor (Composite of fill & stroke) -------------
//
class AbstractShapeColor {
}
class ShapeColor extends AbstractShapeColor {
    constructor(strokeColor, fillColor) {
        super();
        this.strokeColor = strokeColor;
        this.fillColor = fillColor;
    }
    apply() {
        stroke(this.strokeColor);
        fill(this.fillColor);
    }
}
class NoStrokeShapeColor extends AbstractShapeColor {
    constructor(fillColor) {
        super();
        this.fillColor = fillColor;
    }
    apply() {
        noStroke();
        fill(this.fillColor);
    }
}
class NoFillShapeColor extends AbstractShapeColor {
    constructor(strokeColor) {
        super();
        this.strokeColor = strokeColor;
    }
    apply() {
        stroke(this.strokeColor);
        noFill();
    }
}
class NullShapeColor extends AbstractShapeColor {
    apply() { }
}
//
// ------------ Global variables ------------------------------
//
p5.disableFriendlyErrors = true;
const IDEAL_FRAME_RATE = 60;
const UNIT_ANGLE_VELOCITY = (2 * Math.PI) / IDEAL_FRAME_RATE;
let unitLength;
let unitSpeed;
const bodySet = [];
const edgeSet = [];
let myBackground;
let backgroundLineColor;
function distSq(a, b) {
    return sq(b.x - a.x) + sq(b.y - a.y);
}
//
// ------------ Body & Edge ---------------------------------
//
class Body {
    constructor() {
        this.incidentEdgeList = [];
        this.isFired = false;
        this.kinematicQuantity = new KinematicQuantity();
        this.kinematicQuantity.position.x = random(0.1 * width, 0.9 * width);
        this.kinematicQuantity.position.y = random(0.1 * height, 0.9 * height);
        this.rotation = new RotationalQuantity();
        this.rotation.angle = random(TWO_PI);
    }
    static initializeStatic(unitLength) {
        this.displayColor = new NoFillShapeColor(color(255));
        this.displaySize = 10 * unitLength;
    }
    get position() {
        return this.kinematicQuantity.position;
    }
    get velocity() {
        return this.kinematicQuantity.velocity;
    }
    step() {
        this.kinematicQuantity.accelerate(random(-1, 1) * unitSpeed, random(-1, 1) * unitSpeed);
        this.constrainSpeed(10 * unitSpeed);
        this.kinematicQuantity.step();
        this.bounceInWindow();
        this.rotation.angleVelocity = constrain(this.rotation.angleVelocity + random(-1, 1) * 0.05 * UNIT_ANGLE_VELOCITY, -0.3 * UNIT_ANGLE_VELOCITY, 0.3 * UNIT_ANGLE_VELOCITY);
        this.rotation.step();
        if (this.isFired) {
            this.incidentEdgeList.sort(Body.compareDistance);
            for (let i = 0, len = this.incidentEdgeList.length; i < len; i += 1) {
                if (this.incidentEdgeList[i].fire(this))
                    break;
            }
            this.isFired = false;
        }
    }
    draw() {
        translate(this.position.x, this.position.y);
        rotate(this.rotation.angle);
        rect(0, 0, Body.displaySize, Body.displaySize);
        rotate(-this.rotation.angle);
        translate(-this.position.x, -this.position.y);
    }
    fire() {
        this.isFired = true;
    }
    constrainSpeed(maxSpeed) {
        if (this.velocity.magSq() > sq(maxSpeed)) {
            this.velocity.setMag(maxSpeed);
        }
    }
    bounceInWindow() {
        const pos = this.position;
        if (pos.x < 0 || pos.x >= width) {
            this.position.x = constrain(pos.x, 0, width);
            this.velocity.x *= -1;
        }
        if (pos.y < 0 || pos.y >= height) {
            this.position.y = constrain(pos.y, 0, height);
            this.velocity.y *= -1;
        }
    }
} // class Body
Body.compareDistance = (a, b) => {
    return a.distanceSquared - b.distanceSquared;
};
class Edge {
    constructor(bodyA, bodyB) {
        this.distanceSquared = 1;
        this.bodyA = bodyA;
        this.bodyB = bodyB;
        this.electricDischargeRemainingFrameCount = 0;
        this.coolDownRemainingFrameCount = 0;
        this.isFired = false;
        this.firingBody = new Body(); // dummy
    }
    static initializeStatic(frameCountPerSecond) {
        this.electricDischargeDurationFrameCount = Math.floor(frameCountPerSecond / 15);
        this.coolDownDurationFrameCount = Math.floor(1.5 * frameCountPerSecond);
        this.strokeColorArray = [];
        const colors = this.strokeColorArray;
        const lightYellow = color(255, 255, 224, 192);
        const yellow = color(255, 255, 176, 192);
        colors.push(lightYellow);
        colors.push(lightYellow);
        colors.push(yellow);
        colors.push(yellow);
        colors.push(yellow);
        colors.push(yellow);
        colors.push(yellow);
        colors.push(yellow);
        colors.push(yellow);
        colors.push(color(255, 64, 128, 192));
        colors.push(color(160, 255, 160, 192));
    }
    step() {
        this.distanceSquared = distSq(this.bodyA.position, this.bodyB.position);
        if (this.isFired) {
            this.getOtherBody(this.firingBody).fire();
            this.isFired = false;
        }
        if (this.electricDischargeRemainingFrameCount > 0) {
            this.electricDischargeRemainingFrameCount -= 1;
        }
        if (this.coolDownRemainingFrameCount > 0) {
            this.coolDownRemainingFrameCount -= 1;
        }
    }
    fire(firingBody) {
        if (this.coolDownRemainingFrameCount > 0)
            return false;
        if (Math.random() < 0.3)
            return false;
        this.firingBody = firingBody;
        this.electricDischargeRemainingFrameCount = Edge.electricDischargeDurationFrameCount;
        this.coolDownRemainingFrameCount = Edge.coolDownDurationFrameCount;
        this.isFired = true;
        return true; // returns true if the edge was successfully fired
    }
    draw() {
        if (this.electricDischargeRemainingFrameCount === 0)
            return;
        stroke(Edge.strokeColorArray[Math.floor(Math.random() * Edge.strokeColorArray.length)]);
        const directionAngle = atan2(this.bodyB.position.y - this.bodyA.position.y, this.bodyB.position.x - this.bodyA.position.x);
        translate(this.bodyA.position.x, this.bodyA.position.y);
        rotate(directionAngle);
        this.drawZigZag();
        rotate(-directionAngle);
        translate(-this.bodyA.position.x, -this.bodyA.position.y);
    }
    drawZigZag() {
        const maxX = sqrt(this.distanceSquared);
        let x = 0;
        let y = 0;
        let reachedEnd = false;
        beginShape();
        vertex(0, 0);
        while (!reachedEnd) {
            x += random(20 * unitLength);
            if (x > maxX) {
                x = maxX;
                y = 0;
                reachedEnd = true;
            }
            else {
                y = randomGaussian(0, 5 * unitLength);
            }
            vertex(x, y);
        }
        endShape();
    }
    getOtherBody(body) {
        if (this.bodyA === body)
            return this.bodyB;
        else
            return this.bodyA;
    }
} // class Edge
//
// ------------ Setup & Draw etc. ---------------------------------------
//
function setup() {
    createCanvas(windowWidth, windowHeight);
    frameRate(IDEAL_FRAME_RATE);
    unitLength = Math.min(width, height) / 640;
    unitSpeed = unitLength / IDEAL_FRAME_RATE;
    strokeWeight(Math.max(1, 2 * unitLength));
    Body.initializeStatic(unitLength);
    Edge.initializeStatic(IDEAL_FRAME_RATE);
    myBackground = new AlphaBackground(color(32, 32, 16, 192), 4, DIFFERENCE);
    backgroundLineColor = color(192, 192, 255, 32);
    initialize();
}
function draw() {
    rectMode(CORNER);
    myBackground.draw();
    blendMode(ADD);
    for (const eachEdge of edgeSet) {
        eachEdge.step();
        eachEdge.draw();
    }
    blendMode(BLEND);
    rectMode(CENTER);
    Body.displayColor.apply();
    for (const eachBody of bodySet) {
        eachBody.step();
        eachBody.draw();
    }
}
function initialize() {
    bodySet.length = 0;
    // Prepare bodies
    const bodyCount = 40 * (Math.max(width, height) / Math.min(width, height));
    for (let i = 0; i < bodyCount; i += 1) {
        bodySet.push(new Body());
    }
    // Prepare edges
    for (let i = 0, len = bodySet.length - 1; i < len; i += 1) {
        for (let k = i + 1, kLen = bodySet.length; k < kLen; k += 1) {
            const newEdge = new Edge(bodySet[i], bodySet[k]);
            edgeSet.push(newEdge);
            bodySet[i].incidentEdgeList.push(newEdge);
            bodySet[k].incidentEdgeList.push(newEdge);
        }
    }
    // Fire!
    bodySet[0].fire();
}
function mousePressed() {
    initialize();
}
function keyPressed() {
    if (keyCode === 80)
        noLoop(); // 80: 'P'
}
function keyReleased() {
    if (keyCode === 80)
        loop(); // 80: 'P'
}
