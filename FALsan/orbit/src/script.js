// orbit.

// Title: Orbit
// Author: FAL
// Date: 19. Nov. 2017
// Made with p5.js v0.5.16
// Generated by TypeScript v2.6.1

"use strict";
//
// ------------ Array loop utility -------------------------------------
//
function loopArray(array, callback) {
    for (let i = array.length - 1; i >= 0; i -= 1) {
        callback(array[i], i, array);
    }
}
//
// ------------ Array wrapper -----------------------------
//
/// <reference path="ArrayLoopUtility.ts" />
class ArrayWrapper {
    constructor() {
        this.array = [];
    }
    get length() {
        return this.array.length;
    }
    get(index) {
        return this.array[index];
    }
    push(element) {
        this.array.push(element);
    }
    pop() {
        return this.array.pop();
    }
    loop(callback) {
        loopArray(this.array, callback);
    }
}
//
// ------------ Steppable -----------------------------
//
/// <reference path="ArrayWrapper.ts" />
class SteppableArray extends ArrayWrapper {
    static stepFunction(value) {
        value.step();
    }
    step() {
        this.loop(SteppableArray.stepFunction);
    }
}
//
// ------------ Drawable -----------------------------
//
/// <reference path="ArrayWrapper.ts" />
class DrawableArray extends ArrayWrapper {
    static drawFunction(value) {
        value.draw();
    }
    draw() {
        this.loop(DrawableArray.drawFunction);
    }
}
//
// ------------ Sprite -------------------------------------
//
/// <reference path="ArrayWrapper.ts" />
/// <reference path="Steppable.ts" />
/// <reference path="Drawable.ts" />
class SpriteArray extends ArrayWrapper {
    constructor() {
        super(...arguments);
        this.draw = DrawableArray.prototype.draw;
        this.step = SteppableArray.prototype.step;
    }
}
//
// ------------ Random utility -----------------------------
//
function randomSign(n) {
    if (Math.random() < 0.5)
        return n;
    else
        return -n;
}
//
// ------------ Orbital point ------------------------------
//
/// <reference path="../../my_types/p5/p5.global-mode.d.ts" />
/// <reference path="common/Sprite.ts" />
/// <reference path="common/RandomUtility.ts" />
class OrbitalPoint {
    constructor(centerPosition, distanceFromCenter, initialAngle, angleVelocity) {
        this.isVisible = true;
        this.centerPosition = centerPosition;
        this.distanceFromCenter = distanceFromCenter;
        this.angle = initialAngle;
        this.angleVelocity = angleVelocity;
        this.currentPosition = createVector();
        this.previousPosition = createVector();
        this.updatePosition();
        this.previousPosition.set(this.currentPosition);
        this.childPointArray = new SpriteArray();
    }
    step() {
        this.angle += this.angleVelocity;
        this.updatePosition();
        this.childPointArray.step();
    }
    draw() {
        if (this.isVisible) {
            line(this.previousPosition.x, this.previousPosition.y, this.currentPosition.x, this.currentPosition.y);
        }
        this.childPointArray.draw();
    }
    addChild(depth) {
        if (depth <= 0)
            return;
        const distanceFromCenter = random(10, 50) * unitLength;
        const initialAngle = random(TWO_PI);
        const angleVelocity = randomSign(random(0.2, 1.2)) * UNIT_ANGLE_VELOCITY;
        const newPoint = new OrbitalPoint(this.currentPosition, distanceFromCenter, initialAngle, angleVelocity);
        if (depth > 1)
            newPoint.isVisible = false;
        newPoint.addChild(depth - 1);
        this.childPointArray.push(newPoint);
    }
    updatePosition() {
        this.previousPosition.set(this.currentPosition);
        this.currentPosition.set(this.centerPosition.x + this.distanceFromCenter * cos(this.angle), this.centerPosition.y + this.distanceFromCenter * sin(this.angle));
    }
}
//
// ------------ Background ---------------------------------------
//
/// <reference path="../../../my_types/p5/p5.global-mode.d.ts" />
/// <reference path="Drawable.ts" />
class AlphaBackground {
    constructor(backgroundColor, drawIntervalFrameCount = 1, blendModeString, defaultBlendModeString) {
        this.backgroundColor = backgroundColor;
        this.drawIntervalFrameCount = drawIntervalFrameCount;
        this.blendModeString = blendModeString;
        this.defaultBlendModeString = defaultBlendModeString;
    }
    draw() {
        if (frameCount % this.drawIntervalFrameCount !== 0)
            return;
        if (this.blendModeString)
            blendMode(this.blendModeString);
        noStroke();
        fill(this.backgroundColor);
        rect(0, 0, width, height);
        if (this.defaultBlendModeString)
            blendMode(this.defaultBlendModeString);
    }
}
/// <reference path="OrbitalPoint.ts" />
/// <reference path="common/AlphaBackground.ts" />
//
// ------------ Global variables ------------------------------
//
p5.disableFriendlyErrors = true;
const IDEAL_FRAME_RATE = 60;
const UNIT_ANGLE_VELOCITY = 2 * Math.PI / IDEAL_FRAME_RATE;
let unitLength;
let unitSpeed;
let lineColor;
let alphaBackground;
let rootPoint;
//
// ------------ Setup & Draw etc. ---------------------------------------
//
function setup() {
    const canvasSideLength = Math.min(windowWidth, windowHeight);
    createCanvas(canvasSideLength, canvasSideLength);
    frameRate(IDEAL_FRAME_RATE);
    unitLength = Math.min(width, height) / 640;
    unitSpeed = unitLength / IDEAL_FRAME_RATE;
    strokeWeight(Math.max(1, 1.5 * unitLength));
    strokeJoin(ROUND);
    lineColor = color(0);
    alphaBackground = new AlphaBackground(color(255, 4), 1, ADD, BLEND);
    pixelDensity(2);

    initialize();
}
function draw() {
    alphaBackground.draw();
    rootPoint.step();
    stroke(lineColor);
    rootPoint.draw();
}
function initialize() {
    background(255);
    rootPoint = new OrbitalPoint(createVector(0.5 * width, 0.5 * height), 0, 0, 0);
    for (let i = 0; i < 5; i += 1) {
        rootPoint.addChild(13);
    }
    rootPoint.isVisible = false;
}
function mousePressed() {
    initialize();
}
function keyPressed() {
    if (keyCode === 80)
        noLoop(); // 80: 'P'
}
function keyReleased() {
    if (keyCode === 80)
        loop(); // 80: 'P'
}
