ちょっとね。
赤い線うざ。消して。
あー...
パッケージインストールもうできないっぽい、な...

/*

if (this.textureMode === constants.IMAGE) {
  if (this._tex !== null) {
    if (this._tex.width > 0 && this._tex.height > 0) {
      u /= this._tex.width;
      v /= this._tex.height;
    }
  } else if (!this.isProcessingVertices && this._tex === null && arguments.length >= 4) {
    // Only throw this warning if custom uv's have  been provided
    console.warn('You must first call texture() before using' + ' vertex() with image based u and v coordinates');
  }
}

*/
これを、こうする
/*

if (this.textureMode === constants.IMAGE && this._tex !== null && this._tex.width > 0 && this._tex.height > 0) {
  u /= this._tex.width;
  v /= this._tex.height;
}
if (!this.isProcessingVertices && this._tex === null && arguments.length >= 4) {
  // Only throw this warning if custom uv's have  been provided
  console.warn('You must first call texture() before using' + ' vertex() with image based u and v coordinates');
}

*/

これならtextureModeがNORMALの場合にtextureが呼び出されていないにもかかわらずvertexの引数が4以上で
なおかつisProcessingVerticesではない、つまり明示的にvertex系の関数を呼び出している場合にも対応できる
はずです
些細な変更ですが受け入れてもらえると助かります
どうでもいいっちゃどうでもいいけどね

構想
まずcurveVertexに関しては
curveVertexしか出てこないことを前提としたうえで
4つ目の点が出てきたところから
色が格納されているので
その
んー...

firstFillColorとsecondFillColorを用意してですね
firstFillでその、入って、secondFillで入る、で、
firstFillColorが設定されている場合、
curveVertexだったら始点の色はそれで、bezierVertexだったらひとつめのControlPointでquadraticVertexだったら制御点の色。
使われたら破棄する
それがない場合curveVertexだったらまず事前の色があればそれ、無ければ終点と同じ色って感じで。
secondFillも一緒
位置づけ的にはあれ、bezierDetailと似たようなもん
UVも同じやり方で解決できる...と、思うんだけど、どうだろうね。
そういえばnormal関数どうなってるの？？

_currentNormalがあるんだったらさぁ
_currentTexCoordがあってもいいんじゃない？
んでこれが定義されているのであればこれを使う的な？
あー、違う
vertexの引数が3以下で、なおかつこれが定義されていればの話
4とか5の場合はそのときに指定した値が入るのよ
そういう感じでどうよ？
uとvにその、_currentTexCoordを入れちゃって
あとで上書きすればいいのよ

さて
その場合補間されるわけですが
色とかと同じように
うん。
その、えー...
そうやるとですね。色と同じことになるんですよ。
困るので、
色と同じやり方で補間させる必要があると思うんですよね
できれば線の色も同じように...
そこらへんは、まあ、あれがうまくいってからですよね。
そんな感じで考えてます。

_currentTexCoordになんか入れる関数はtexCoord(u, v)でいいと思う
んで...
ベジエとかの場合はそれ、したがって、補間でいいと思うんだ、
でもcurveVertexの場合は色と同じ問題（最初の曲線に関して始点と終点で異なる特徴を付与できない問題）が生じるので難しい
bezierとquadraticは問題なし
とにかく今の問題が解決しないとだ
そのうえで
まあ
...
firstFill, secondFill, firstTexCoord, secondTexCoord, firstNormal, secondNormal.....
需要あるのか？？？？
firstFillはわかるけどそれ以外要らなくないか...？？？んー。
secondFillもまあ要るかもしれないけど...んー。

関数の実装はハードル高いよなぁ。
やったことないし
まあ
normalと同じように作ればいいのか？ただそれにとどまらない気がして...
あーハードル高そうだ...どうなるかね...
まあ似たような感じで作ればいいのか
で
色の補間がうまくいったらその中で...
法線の補間は

はい。レビュー大量に来ました！がんぼるぞいっ

あと直すポイント
変数の役割をコメントで明確化するとともにループ内の処理を簡潔に書き直し
これはあれ、将来線の色やUVも補間しようってなったときにそうするべきなので
てかUVはnormalみたくtexCoordって関数作る手があると思うけどね...
それ通ったらunit testとの格闘が...それ終わったらうまくいきそうだけどわからんね

texCoordはいけるとおもうんだよな
一応大文字小文字で「texCoord」は引っかからないです。いけます。多分。

magとdistって速くできないの？？？
素人仕事では速くなりませんでした（無力）

curveDetail.
curveVertexの場合どうするか？

ひとつ
3つ目の頂点呼び出し前にfillなりstrokeするとvertexが1回...
あー
だから

table作成パートは一緒なのでカット

簡単です
変更点1: this.immediateMode._curveVertex.lengthが6ないしは9の場合に後ろから2つ目の点に対してvertexを呼び出す。
        1回だけでいいです。isCurveもこの時点ではtrueにしなくていいです。shiftとかも全部要らないですね。
変更点2: あとはbezierやquadraticと同様に色の補間などを行うだけです。
今回control pointが無いので、普通の補間でいいと思います。どうせうまいやり方なんかないので。
？？？
ああなるほど。でもなぁ
難しいと思う
...vertexを毎回呼んで格納するってこと？えぇ...だめでしょ。...

BezierToCutmullで現れる頂点にしかるべく色を配すればいける、かもね。
合理的な割り当て。
その方が合理的かなぁ。知らんけど。

uMaterialColorを使ってるいくつかのfragについてそこをvColorで置き換えて
それとペアになりうるvertでaVertexColorとvColorとuMaterialColorとuUseVertexColorを実装する
vColorはuUseVertexColor == false;の場合uMaterialColorrでtrueの場合aVertexColor. これをfragに送る。あとは一緒。
合わせるためにuUseLineColorをuUseLineVertexColorに改名する
今シェーダーに送る方がlineVertexColorsという名前なので、整合性を取るため。
vertexColors ------- uUseVertexColor,     _useVertexColor
lineVertexColors --- uUseLineVertexColor, _useLineVertexColor だと正確な気がする。

仕様変更詳細（これでラスト！）
step1: uUseLineColor → uUseLineVertexColor, _useLineColor → _useLineVertexColor 改名
step2: フラグ_useVertexColorをジオメトリーに導入する。これはシェーダーに投入する直前に、
       vertexColorsのlengthが正かどうかで決める。
step3: uMaterialColorを使っているフラグメントシェーダーについてそれをvec4のvColorで置き換える
step4: fillShaderでuMaterialColorを使っているフラグメントシェーダと対になって使われているバーテックスシェーダに
       vec4のvColorを導入、あとuMaterialColorとaVertexColorも追加。さらにvarying vec4 vColorも追加。
       boolのuUseVertexColorも追加！そしてこのフラグでvColorを分岐決定する。
以上です。
不備？
この時出てくるバーテックスシェーダが対応するフラグメントシェーダで漏れてるのがあるかもしれないな...ちょっと気になるので
もうこの際
ていうかどういうときどのシェーダーが使われるのかもういい加減はっきりさせた方がいいな
レファレンス不親切すぎるんだよな
まずすべてのデフォルトシェーダを洗い出して...


実験的にbezierVertexだけ_currentTexCoordの補間やってみたけど
駄目
使い物にならない
原因はおそらく縦ベースの雑な_triangulateのせい
こりゃ
無理だわ
