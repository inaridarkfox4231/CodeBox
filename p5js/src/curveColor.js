// このコードで赤と白がグラデーションするようにしたいのよ
// 今後やりたいことは主に2つ

// ひとつはbezierとquadraticのcurveで色のグラデーションがつくようにする（できれば線も）。
// もうひとつは2Dのcurveで頭とおしり、重複して点の呼び出しをしなくて済むように変更
// 同じ頂点を2回呼ぶのが不自然であるため（カットマルロムの仕様によるんだけど利用者がそれを知る必要はないので）
// この2つです。落ち着いたらissueを上げます。

// って思ったけどどうもやらない方がいいみたい...？
// あんま意味ない気はするけど。残した方がいいのかもな。
// というかcurveVertexの仕様がいまいちわからんのよね...

// issue: Allow vertex-wise coloring of areas bounded by bezier and quadratic curves in webgl
// webglにおいてbezier曲線およびquadratic曲線で囲まれた図形の着色を頂点ごとに行えるようにする

// 線についても補間されるようにしたいですね。なので今の案件が終わらないと取り組めません。

// 一応一通りテストできました。プレゼン用。これでいこう。

// やっぱあれ片づけて...いや、ブランチ...
// だめだ。mainいじってるから別のfork作らないとだめだ。
// ああもう！最初からブランチで
// 今更だよ
// 仕方ないから片付くまで待つわ。

// なるほど～
// まあratioはダメだしされると思ってたよ（それはそう）
// そうねー
// おそらくdavepagurekさんのいうbezierControlPointっていうのは
// bezierVertexでまとめてやってたのを個別にやろうっていう
// 話で
// UVの問題も絡んでくるめんどくさい話で
// うえー
// controlPointにUVを割り当てて補間...現状では無理なやつね。
// それが今できないわけですけど
// それも？？？
// bezierControlPointを使って個別に...ああなるほど...そうねー
// でもあれ
// ぶっちゃけどっちがいいのかわかんなくない？
// 領域指定に使う（クリッピングみたいな感じ）のか
// 境界を指定してゆがめるのか
// 判断つかないし
// 境界指定するにしても
// 補間値も境界値になるとは
// 限らないでしょ
// それとも補間値が境界になるように設定？それは無理でしょう
// 円ならともかく正方形の境界は複雑ですから
// ...
// とはいえたとえば全部yが0とか1とかなら今の方法で全部0とか1になるから
// 辺に関しては不可能ではないわね
// んー...できそうな気がしてきたわね...
// となると
// bezierControlPointを作る？ということは現在のbezierVertexは格下げ？
// にはならんだろう
// 廃止にはならないと思う
// 便利だし
// 形としてはbezierVertexは普通に残すことにしたうえで

// bezierControlPointに関してはまああれおそらくだけど
// 3つ呼び出されるごとにbezierVertexが呼び出されて...でもないか
// controlPointに色が割り当てられてるので
// それを...

// でもなぁ
// たとえば両端だけ色決めてあと適当に補間してね～しくよろ！
// って場合に
// 手動で補間値計算するのめんどくさくないか？

// だからそこらへんは見送ることにしたうえで
// んー...
// 結局UVって個別に指定するしかないんで
// 姑息ではあるけど
// 両端の色を単純に線形補間...あの、始端と終端を結ぶ線に対して垂線引いてその割合で決める感じ
// だとまずいね
// 色がはみ出しちゃう
// 答えがないぞ？？？
// 2-2で。それで同じになるはず。とりあえず。

// 行きと帰りが同じ色になるならとりあえずそれでいいでしょう。
// だめだろ
// 2-2じゃ同じ色の範囲が広がってしまう
// とはいえ垂線おろして補間するとはみ出してしまうし
// んんーーー
// はみ出すのは仕様か？
// いや、はみ出した場合でもきちんと...？？？
// 始端と終端を結ぶ直線に対して
// どんな平行線を引いて補間するのかが判然としないので
// そこがネック
// 傾いているのか
// まっすぐなのか
// 両側に存在するのか
// そのせいで補間が難しい
// かといって
// bezierControlPointに頼るとなると
// 補間する色を自分で決めないといけないので
// そこが手間...
// まあでも仕方ないのか？

// controlPointがどこにあるのかわからない以上
// 補間を例の数字、ratioでやるのは無理で
// そうなると手動で決める必要があるので
// ...

// 今の仕様でいいって言ってくれる人がいるので
// とりあえずこれをこの形で実装して
// より詳しい設定の仕方は後日改めてっていう形の方が
// 個人的には
// いいかな～と
// 思うね！
// だってUVで使うとは限らないでしょ、単に色当てたいだけの場合のが、ねぇ、
// 個別に色充てるのめんどくさいからratioによる線形補間でいいっていう人も
// いるでしょうし
// ねぇ
// だからとりあえずその期待に応えたうえで
// 改めて考えるべきではないかと
// 思います。以上！

// さてと
// とりあえずduplicateして。

function setup() {
  createCanvas(400, 400, WEBGL);

  beginShape();

  fill(255);
  vertex(0, -200);

  fill(255, 0, 0);
  bezierVertex(200, -200, 200, 0, 0, 0);

  fill(0, 0, 255);
  bezierVertex(-200, 0, -200, 200, 0, 200);

  endShape();
}
